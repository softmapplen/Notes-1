# 垃圾收集器与内存分配策略

程序计数器、虚拟机栈、本机方法栈随线程而生，随线程而灭；这几个区域的内存分配和回收都具有确定性，不需要过多考虑回收的问题。而**Java堆和方法区** ，一个接口中的多个实现类需要的内存可能不一样，一个方法的中的多个分支需要的分支可能不一样，只有在程序处于运行期间时才能知道会创建哪些对象。

## 判断对象是否已经死亡

### 引用计数算法

引用时加一，引用失效时减一

缺点：很难解决对象之间相互循环引用的问题

### 可达性分析算法

通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明该对象时不可用的。

### 引用的分类

**强引用（Strong Reference）**

垃圾收集器永远不会回收掉被引用的对象

**软引用（Soft Reference）**

系统发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。

**弱引用（Weak Reference）**

只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。

**虚引用**

不会对其生存时间构成影响，无法通过一个虚引用来取得一个对象的实例。唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

### 回收Java堆——两次标记来决定一个对象死亡

第一个阶段：经过可达性分析以后发现没有与GC Roots相连接的引用链，被第一次标记并行进行一次筛选。筛选的条件时是否有必要执行**finalize()**方法。当对象没有覆盖finalize（）方法时或者finalize（）方法已经被虚拟机调用过，视为“没有必要执行”。当这个对象有必要执行finalize（）方法，那么这个对象会放置在F-Queue之中，稍后由虚拟机自动建立的、低优先级的Finalizer线程去执行它。

> 这里的执行是指虚拟机会触发这个方法，但并不承诺等待它运行结束。原因是如果对象在finalize（）方法中执行缓慢，或者发生了死循环，将可能会导致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收系统崩溃。

第二个阶段：GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize（）中成功拯救自己，只要重新与引用链上的任何一个对象建立关联即可，那么它将在第二次标记时被移出“即将回收”的集合；如果对象这时候还没有逃脱，那就被真正的回收了。

> 任何一个对象的finalize（）方法只会被系统自动调用一次

### 回收方法区

主要回收两部分内容：废弃的常量和无用的类

**废弃的常量**：和回收对象相似，如果没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果这时候发生内存回收，而且有必要的话，那么这个“abc”常量会被系统清理出常量池。

**无用的类**：判定依据有三点

- 该类所有的实例已经被回收
- 加载该类的ClassLoader已经被回收
- 该类对应的java.lang.class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

## 垃圾收集算法

### 垃圾-清除算法（Mark-Sweep）

效率问题，标记和清除两个过程的效率都不高

空间问题：标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序分配大对象时，无法找到足够的连续内存而不得不提起触发另一次GC。

### 复制算法（Copying）

将可用内存按容量分为大小相等的两块，每次只使用其中的一块。当一块的内存使用完了，就将还存活着的对象**复制**到另一块上面，然后再把已使用过的内存空间一次清理掉。

优点：不需要考虑内存碎片问题，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。

缺点：算法的代价为将内存缩小了原来的一半。即使有8:1的分配，**对象存活率较高时**就要进行很多的复制操作，效率会变低。除此之外还需要额外的空间作为分配担保，不适合所有对象100%存活的极端情况，**不适合老年代使用**。

HotSpot复制算法策略：将内存分为一块较大的Eden和两块较小的Survivor，每次使用Eden和其中一块Survivor。回收时，将Eden和Survivor中还存活的对象一次性复制到另一块Survivor中，最后清理掉Eden和Survivor空间。Eden：Survivor=8:1。

> 如果另一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象，这些对象将直接通过**分配担保**机制进入老年代。

### 标记-整理算法（Mark-Compact）

根据老年代的特点，提出该算法。先进行标记，然后让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

### HotSpot收集算法实现

#### GCRoots枚举

可达性分析工作必须在一个能确保一致性的快照中进行，GC进行时必须停顿所有Java执行线程（**Stop The World**）

不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机使用一组称为**OopMap**的数据结构直接得知哪些地方存放着对象引用。

#### 安全点

只有在特定位置上来记录信息，只有在到达安全点时才能暂停。

这些位置的选定标准：是否具有让程序长时间执行的特征。指令序列复用，例如方法调用、循环跳转、异常跳转，具有这些功能的指令才会产生SafePoint。

问题：如何GC发生时让所有线程都跑到最近的安全点上再停顿下来？

抢先式中断：所有线程中断，如果发现线程中断的地方不在安全点上，就恢复线程，让它跑到安全点上。

主动式中断：GC需要中断时，不直接堆线程操作，仅仅简单地设置一个轮询标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。

#### 安全区域

如果线程处于Blocked或者Sleep状态时，无法响应JVM的中断请求。

安全区域是指一端代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。

当线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，当JVM发起GC时，就不用管自己为Safe Region状态的线程了。在线程离开安全区时，它要检查系统是否已经完成了根节点枚举，如果完成了，那线程就继续执行否则它就等待直到收到可以安全离开Safe Region的信号为止。

## 垃圾收集器

HotSpot垃圾收集器的图片

### Serial收集器

**单线程**集器，进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。新生代采用复制算法，老年代采用标记-整理算法

优点：简单高效；在用户的桌面应用场景中，分配给虚拟机管理的内存不会很大（几十兆或者几百兆）停顿时间完全可以控制在几十毫秒最多一百毫秒以内。使用于运行在**Client模式**下的虚拟机

### ParNew收集器

Serial收集器的多线程版本，使用于工作在**Server模式**的虚拟机，**目前只有它能与CMS收集器配合工作**

在单CPU的环境中绝对不会有比Serial收集更好的效果

### Parallel Scavenge收集器

吞吐量优先收集器：**关注点不同**，其他收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目的是达到一个可控制的吞吐量。吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值。

设置参数：最大垃圾收集停顿时间 -XX:MaxGCPauseMillis 直接设置吞吐量大小 -XX:GCTimeRatio，开关参数：-XX:+UseAdaptiveSizePolicy，不要设置手工指定新生代大小、比例、晋升老年代对象大小等细节参数，**GC自适应的调节策略**。这点是与Parnew收集器重要区别。

### Serial Old收集器

单线程，标记整理。主要意义是在于Client模式的虚拟机使用。

如果在Server模式有两大用途：在JDK1.5版本以及之前的版本中，与Parallel Scavenge收集器搭配。作为CMS收集器的后备预案，Concurrent Mode Failure时使用。

### Parallel Old收集器

Parallel Scavenge的老年代版本，使用多线程和“标记-整理”算法。

适用于注重吞吐量以及CPU资源敏感的场合，可以优先考虑Parallel Scavenge 加 Parallel Old。

### CMS收集器

一种获取最短回收停顿时间为目标的收集器，重视服务器的响应速度，希望系统停顿时间最短，给用户带来较好的体验。

标记-清除的运作过程：

**初始标记**只是标记一下GC Roots能直接关联到的对象，速度很快。**并发标记**阶段进行GC Roots Tracing的过程，而**重新标记**阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象，这个阶段的时间比初始时间稍长，但远比并发标记时间短。最后**并发清除**标记的对象。

缺点

- CMS收集器对CPU资源非常敏感。虚拟机提供了一种“增量式并发收集器”，尽量减少GC线程的独占资源的时间。效果一般，已经被弃用。
- CMS收集器无法处理浮动垃圾，可能出现Concurrent Mode Failure失败而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行，伴随程序运行自然还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，这一部分垃圾称为浮动垃圾。CMS收集器需要预留一部分空间提供并发收集时的程序运作使用。JDK1.6CMS的启动阈值为92%，要是CMS运行期间预留的内存无法满足程序需要就会出现一次“Concurrent Mode Failure”。
- 收集结束会有大量的空间碎片产生。给分配大对象带来很大麻烦，如果没有找到足够的空间来分配当前对象就会触发一次Full GC。使用-XX：+UseCMSCompactAtFullCollection开关参数开启内存碎片的合并整理过程，内存过程无法并发，空间碎片没有了，但停顿时间不得不变长了。

### G1收集器

面向服务端应用的垃圾收集器

特点

- 并行与并发：充分利用多CPU、多核环境的优势
- 分代收集
- 空间整合：整体使用标记-整理，局部之间使用复制。将Java堆分为多个大小相等的独立区域。
- 可预测的停顿：相对于CMS的另一大优势。建立**可预测的停顿时间模型**，有计划的避免进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收获得时间大小以及回收所需时间的经验值） 在后台维护一个优先列表，每次根据允许的收集时间，**优先**回收价值最大的Region。

每个Region都有一个与对应的Remembered Set来避免全堆扫描。

G1收集器运作：初始标记、并发标记、最终标记、筛选回收

## 内存分配与回收策略

- 大多数对象优先在Eden中分配，当Eden区没有足够空间进行分配时，虚拟机发起一次Minor GC
- 大对象直接进入老年代，使用-XX：PretenureSizeThreshold参数令大于设置值对象直接在老年代中分配。该参数只能在Serial和ParNew中使用
- 长期存活的对象直接进入老年代。每熬过一次Minor GC年龄就增加一岁，当超过默认15岁就会晋升到老年代。通过设置-XX:MaxTenuringThreshold
- 动态对象年龄判定：如果在Survivor空间中相同年龄所有对象大小的总和大于或等于Survivor空间的一半，年龄大于或等于该年龄的对象直接进入老年代
- 空间分配担保：在发生Minor GC前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间或者历次晋升的平均大小，如果条件成立，则可以确保Minor GC是安全的。否则就会进行一次Full GC。

