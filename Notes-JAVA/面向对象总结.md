# 本章的三条主线
-  java类以及类的成员
- 面向对象的三大特征 (**封装 继承 多态 抽象**)
- 其他的关键字
*this super package import static final abstract interface* ...
---

# 面向对象
## 面向对象与面向过程
- 过程：强调功能的*行为*
- 对象：强调功能的**对象**
例子：人把大象装进冰箱
  
    面向过程：
    	1.打开冰箱 2.把大象放进去 3.关闭冰箱
    面向对象：
        人
        { 
           打开(冰箱){冰箱.开开()}
           操作(大象){大象.进入(冰箱)}
           关闭(冰箱){冰箱.合上()}
         }
         大象
         {进入(冰箱){}}
         冰箱
         {
    	     开开(){}
    	     合上(){}
         }
##  类与类之间的关系
1. 关联关系
2. 继承关系
3. 聚集
4. 组合
## 面向对象编程的特征
> 封装性 继承性 多态性 （抽象性）


# JAVA语言的基本元素——类和对象
> 类与对象的**关系**和==设计图与设计出来的实体==对应。



## 类的属性
> 按照声明位置的不同分为**成员变量**和**局部变量**

不同点：
1. 声明位置不同
		成员变量：类里方法外。局部变量：方法内部和方法的形参部分
 2. 成员变量的修饰符有四个：**public private protected 缺省**。而局部变量没有修饰符，与所在方法的修饰符相同。
  3. 初始化值：**一定会有初始化值**。

    局部变量没有默认值，所以一定要赋值。
  4. 在内存中**存放位置**不同。
	  局部变量在栈空间而成员变量在堆中。
## 类的方法
> 提供某种功能的实现

###  格式
```java
public void eat(){}
格式：权限修饰符 返回值类型(void / 具体返回值) 方法名(形参){}
```
注意：
- void 方法不需要返回值。使用**return**来返回
- 方法内可以调用本类的**其他方法或成员变量**，但是不能在方法内再定义方法

###  方法的重载 *overload*
要求：
1. 同一个类中 
2. 方法名必须相同 
3. 方法的参数列表不同(参数个数或者参数的类型，次序)
> 方法的重载与方法的返回值类型**没有关系**

### 可变个数的形参
```java
数据类型 ... 形参名
public int sayHello(int ... number)
{
	int sum=0;
	for (int i=0;i<number.length;i++)
		sum+=number[i];
	return sum;
}
```
- 个数不限
- 使用可变多个形参的方法与方法的形参**使用数组**是一致的
- 若方法中存在可变个数的形参，必须放在最后。也就是说，一个方法中只能有一个可变个数的形参。
### 方法的参数传递
 规则：java中的参数传递机制都是**值传递机制。**
 1. 形参是基本数据类型的
将实参的值传递给形参的基本数据类型的变量
 3. 形参是引用数据类型的
将实参的引用类型变量的值(对应的heap空间的对象实体的**首地址值**)传递给形参的引用类型变量。

## 构造器(构造方法)
> constructor : 创建对象和初始化属性

1. 设计类时，若不显式声明类的构造器，程序会默认提供一个**空参的构造器**
```java
class Person
{
	private String name;
	private int age;
	//构造器
	public Person(String n)
	{
		name=n;
	}
	public Person ()
	{
	}
}
```
2. 一旦显式的定义类的构造器，那么默认的构造器不再提供。
3. 如何声明类的构造器。权限修饰符  类名 （形参）
4. 构造器之间可以构成重载

## 初始化块（或代码块）
用来初始化类的属性。如果要有修饰的话，那么只能使用*static*。按照修饰方法分为**静态代码块**和**非静态代码块**

#### 静态代码块
- 可以有输出语句
- 多个代码块之间按顺序执行
- 随着类的加载而加载
- 静态代码块的执行要早于非静态代码块
- 静态代码块中只能执行静态的结构(类属性，类方法)
#### 非静态代码块
- 可以有输出语句
- 一个类中可以有多个非静态代码块，多个代码块之间按顺序结构进行。
- 可以对类的属性进行初始化操作
- 每创建一个类的对象，非静态代码块就加载一次
- 非静态代码块的执行要早于构造器
### 关于属性赋值操作
1. 默认初始化 
2. 显式的初始化或代码块初始化
4. 构造器中
5.  通过方法对对象的属性进行修改
~~~java
class Order{
	private int orderId;
	private String orderName;
	//静态代码块1
	static{
		System.out.println("我是静态代码块1");
	}
	static{
		System.out.println("我是静态代码块2");
	}
	//非静态初始化块
	{
		orderId=1002;
		orderName="AA";
		System.out.println("我是非静态代码块1");
	}
	{
		orderId=1003;
		orderName="BB";
		System.out.println("我是非静态代码块2");
	}
}
~~~
## 内部类
类中类
成员内部类(类内方法外)、局部内部类(方法内部)

### 成员内部类
1. 是外部类的一个成员
可以有修饰符(4);static final 
2. 具有类的特点
属性方法构造器;abstract
### 局部内部类
### 掌握三点
1. 如何创建创建成员内部类的对象
2. 如何区分调用外部类、内部类的变量
3. 局部内部类的使用

## Object类及其方法
> java.lang.Object类是所有类的**根父类**
>
> -  基本数据类型：根据基本数据类型的值判断是否相等。相等返回true反之false
- 引用数据类型：比较引用类型变量的地址值是否相等

### equals
1. 只能处理引用类型变量
2. 在Object类，发现equals()仍然比较的两个引用变量的地址值是否相等
3. 像String 包装类File Date这些重写Object类的equals()方法，比较两个对象的”实体内容“是否完全相同

### toString
~~~java
   public String toString() {
        return getClass().getName() + "@" + Integer.toHexString(hashCode());
    }
    //返回对象所在的类及对应的堆空间的首地址值
~~~
当打印一个对象的引用时，实际上默认调用的是这个对象的toString方法
当打印对象所在的类没有重写Object中的toString()方法时，那么调用的就是Object中定义的toString()方法。
重写的规范：将对象的属性信息返回

## 包装类Wrapper
基本数据类型|boolean|byte|short|int|long|char|float|double|
----------------|----------|------|---|-----|-----|-----|---|--|--
包装类|Boolean|Byte|Short|Integer|Long|Character|Float|Double|

> Junit单元测试类
> 1. 当前工程下右键-build path - add libraries -Junit4
> 2. 在主类中，创建一个空参的无返回值的方法。在方法上声明@Test
> 3. 导入import org.junit.Test;
>  4. 在test()方法中，进行代码的编写
>  5. 测试:双击方法名，右键run as - junit test

包装类 —> 基本数据类型：调用包装类XXX的XXXValue()方法
JDK5.0 以后，自动装箱和拆箱

~~~java
int i4=i2;
Integer i3=i4;//自动装箱
Boolean bb=false;
int i5=i3;//自动拆箱
~~~
### 基本数据类型、包装类与String类之间的转换
~~~java
//基本数据类型、包装类 ---> String类:调用String类的重载的valueOf(XXX x)方法
int i1=10;
String str1=i1+"";//"10"

String str2=String.valueOf(i1);
String str3=String.valueof(true);//"true"
//String 类 ---> 基本数据类型、包装类：调用包装类的parseXxx(String str)方法
int i3=Integer.parseInt(str2);
~~~

## *JavaBean*
提供了一种随时随地的复制和粘贴功能，符合以下标准的类：
1. 类是公共的
2. 有一个无参的公共的构造器
3. 有属性，且有对应的get、set方法

# 面向对象特征之—封装和隐藏
##  封装
1. 当创建了类的对象以后，如果直接通过“对象.属性”的方式对相应的对象属性赋值，可能会出现不满足实际情况的意外，我们考虑不让对象来直接作用属性，而是通过“**对象.方法**”的形式，来控制对象对属性的访问。实际情况中，对属性的要求就可以通过方法来体现。
2. 封装性的思想：将类的属性私有化(private),并且只能通过方法(get & set)来访问修改。
### 权限修饰符
> public 
> protected
> 缺省 *default*
> private

权限修饰符  | 类的内部 | 同一个包|子类|任何地方
-|:-:|:-:|:-:|:-:|
private|yes|no|no|no|
default|yes|yes|no|no|
protected|yes|yes|yes|no|
public|yes|yes|yes|yes|yes|

修饰class只有**public**和**default**
- public的类可以在任意地方被访问
- default只可以被同一个包内部的类访问
## 继承
1. 为什么需要设计继承性？
2. 如何来实现类的继承？
*class A **extends** B*  
子类(SubClass)->A      父类(SuperClass)->B
3. 子类继承父类以后，父类中声明的属性方法都可以在子类中使用。
注：父类的私有的属性或方法，子类可以获取得到，但是由于封装性的设计，使得子类不可以直接调用。
**extends**: 子类是父类的一个“扩展”，而非子集。
4. java只支持**单继承**：一个类只能继承一个父类。一个父类可以有多个子类。
5. 子类和父类是相对的概念
6. 可以对父类方法的重写(覆盖)
- 父类的方法对子类不适用，那么子类可以对父类的方法重写(override overwrite)
- 重写规则有：
  - 要求子类方法的“返回值类型 方法名 （参数列表）”与父类的方法一样
  - 子类的方法修饰符不能小于父类的方法
  - ~~若父类方法抛异常，子类方法抛的异常类型不能大于父类。~~(未学习到)
  - ~~子父类方法必须同为static或同为非static的。~~
  
## 多态性
 多态性指的是什么？
 : 可以理解为一个事物的多种表现形态

 > 方法的重载和重写
 > **子类对象的多态性:父类的引用指向子类对象**，虚拟方法调用

 ### 使用前提
 > 1. 类的继承 
 >  2. 子类对父类方法的重写

### 程序运行分为编译状态和运行状态
对于多态性来说，编译时，"看左边"，将此引用变量理解为父类的类型
运行时，“看右边”，关注于真正对象的实体：子类的对象。那么执行的方法就是子类重写的。

### 强转符( )——向下转型
在转换之前，使用*instanceof*进行判断是否可以满足转换
格式：对象a  instanceof 类A，判断对象a是否是类A的一个实例，是返回true否则false。

> 注意：子类对象的多态性，并不适用于属性。

## 抽象类
### abstract 修饰类
1. 不可被实例化
2. 抽象类有构造器，所有类都具有构造器
3. 抽象方法所在的类一定是抽象类
4. 抽象类中可以没有抽象方法
### 修饰方法
1. 格式：没有方法体，包括{}，例如public abstract void eat();
2. 抽象方法只保留方法的功能，而具体的执行交给继承抽象类的子类，由子类重写此抽象方法。
3. 若子类继承抽象类，并重写了所有的抽象方法，则此类是一个实体类，即可以实例化
4. 若子类继承抽象类，没有重写所有的抽象方法，则此类还是抽象类
> abstract不能用来修饰属性、构造器、private、final、static

### 特殊的抽象类——接口*Interface*
是与类并行的一个概念
- 可以看成特殊的抽象类，只定义属性(只能是常量)和方法(抽象)
- 接口定义的就是一种功能，此功能可以被类实现(*implements*)
- 实现接口的类，必须要重写其中所有的抽象方法，方可实例化。否则该类为抽象类
- 接口与具体的实现类之间也存在多态性
- 类可以实现多个接口，但继承只能是单继承
- 接口之间可以继承，而且可以实现多继承
~~~java
interface AA{
	//所有的常量默认都是用public static final 修饰
	int I=12;
	public static final boolean FLAG=false;
	//所有的方法默认都用public abstract修饰
	public abstract void method1();
	void menthod2();//等价于public abstract void method2()
}
~~~





# 几个关键字

## *this*
1. 可以修饰属性、方法、构造器
2. this可以理解为当前对象或当前正在创建的对象
3. 可以在构造器中通过**this**(形参)的方式显示的调用本类中**其他重载**的指定的构造器。
	> 在构造器内部的声明必须放在首行
	**this(*parameter*)** 来调用本类中其他重载的构造器
	> 若一个类中有n个构造器，那么最多有n-1个构造器可以使用**this**

## *super*
修饰属性、方法、构造器
- 当子类与父类有同名的属性时，可以通过**super.属性**显式的调用父类中声明的属性
- 当子类重写父类的方法以后，在子类中若想再显式的调用父类的被重写的方法，就需要使用**super.方法**
- super修饰构造器：通过在子类中使用**super(形参列表)**来显式调用父类中指定的构造器
  - 在构造器内部，super必须要声明在首行
  - 在构造器内部，*this(形参列表)* 或 *super(形参列表)* 只能出现一个
  - 当构造器中不显式的调用*this(形参列表)* 或 *super(形参列表)* 其中的任何一个，默认调用的是父类空参的构造器
  - 建议：设计一个类时，尽量要==提供一个空参的构造器==！


## *import*
1. 显式导入指定包下的类或接口
2. 写在包的声明和源文件之间
3. 如果需要引入多个类或接口，那么就并列写出
4. 如果导入的类是*java.lang*包下的，就不需要显式的声明
5. 理解 * 的概念上，比如 *java.util.*
6. 如何处理同名类的导入，如,在util包和sql包下同时存在Date类。
> 显式的将整个包表示出来: ***java.sql.Date** d1=new **java.sql.Date**(1114314)*;
8. *import static* 表示导入指定类的static的属性或方法
9. 导入java.lang.* 只能导入lang包下的所有类或接口，不能导入子包
```java
JDK主要包介绍
java.lang 	一些java语言的核心类，例如String，Math，Integer,System,Thread
java.net 	包含执行与网络相关的操作的类和接口
java.io 	包含能提供多种输入/输出功能的类
java.util 	包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数
java.text 	包含一些java格式化相关的类
java.sql 	包含java进行JDBC数据库编程的相关类/接口
java.awt	构成抽象窗口工具集的多个类，这些类被用来构建和管理应用程序的图形用户界面
java.applet	applet运行所需的一些类
```

## *static*
静态的，可以用来修饰属性和方法、代码块(或初始化块)、内部类。使用于不依赖对象本身的情况
### 属性
实例变量：存储在堆空间
与类变量：存储在静态域

1. 由类创建的所有的对象，都共用这一个属性
2. 当其中一个对象对此属性进行修改，会导致其他对象对此属性的一个调用。
3. 类变量是随着类的加载而加载，而且只有这一个，即类变量的加载要早于对象。
4. 静态的变量可以直接通过“类.类变量”的形式来调用，也可以通过“对象.类变量”使用。
### 方法
1. 随着类的加载而加载，在内存中也是独一份
2. 可以直接通过“类.类方法“的方式调用
3. 静态的方法内只能调用静态的属性、静态的方法，而不能调用非静态的属性或方法。反之，非静态的方法可以调用静态的属性或方法。
> 静态的结构的生命周期要早于非静态的结构，同时被回收也要晚于非静态结构。
> static的一个应用：使用静态变量可以实现“累加”的效果，因为静态变量在内存中独一份



## *final*
可以用来修饰类、属性、方法
1.  修饰类
这个类不能被继承，如String、System、StringBuffer
2. 修饰方法
不能被重写
1. 修饰属性
此属性就是一个常量，一旦被赋值就不能再修改。习惯上用大写字符表示。不能使用默认初始化，可以显式的赋值、代码块、构造器。

如果一个变量用static final 修饰：全局常量


# 设计模式
23种设计模式
## 单例设计模式
1. 解决的问题:使得一个类只能创建一个对象
2. 如何实现
### 饿汉式
~~~java
//1.私有化构造器,使得在类的外部不能够调用此构造器
private Singleton(){
}
//2.在类的内部创建一个类的实例
//3.并私有化对象，通过公共的方法来调用
private static Singleton instance =new Singleton();
//4.此公共的方法只能通过类来调用，因为设置为static的，同时类的实例也必须为static声明的
public static Singleton getInstance(){
	return instance;
}
~~~
### 懒汉式
==可能存在线程安全问题==
~~~java
//1.私有化构造器
private Singleton(){
}
//2.在类的内部创建一个实例，并私有化对象，只能通过公共的方法来调用
private static Singleton instance=null;
//3. 公共的方法只能通过类来调用，设置为static，类的实例也要是static的
public static Singleton getInstance (){
	if(instance==null){
		instance=new Singleton();
	}
	return instance;
}
~~~
## 模板方法设计模式

###  main方法
~~~java
//主方法，是程序的入口
public static void main (String[] args){
	for(int i=0;i<args.length;i++)
		System.out.println(args[i]);
}

class Main{
	public static void main (String[] args) {
		for (int i=0;i<args.length;i++) {
			args[i]="value_"+i;
		System.out.println(args[i]);
		}
		}
}
~~~
public static void main(String[] args){ }
权限修饰符:public protected default private
关键字static:
对于方法来讲：static final abstract
方法的返回值：void / 具体的返回值类型(基本数据类型和引用数据类型)
方法名：命名规则：xxxYyyZzz，见名之意
形参列表：同一个方法名不同的形参列表的诸多个方法间构成重载。形参和实参机制：值传递
方法体：一种功能，具体的实现。


# 总结
类及类的成分 
1. 关注于类的设计，并列关系、关联关系、继承关系、聚合关系
2. 类的成员：属性、方法、构造器、代码块、内部类

属性
成员变量(属性Field)和局部变量(形参、方法内部、代码块内部)
基本数据类型(8种，不同的数据类型对应不同的默认初始化值)vs引用数据类型

三大特性 
 关键字
this super import abstract final static interface package

