- 给定一个网址，访问这个网址经过了那些过程？涉及哪些协议？
- HTTP and HTTPS
  - HTTP报文格式
  - HTTP方法及相互区别
  - HTTP的无状态
  - HTTP状态码
  - HTTP 1.0 vs 1.1 vs 2.0
  - HTTP vs HTTPS
  - HTTP安全性
  - HTTP底层协作协议（如传输层为TCP协议）

# HTTP介绍

什么是Http协议无状态协议?怎么解决Http协议无状态协议?

HTTP协议自身不对请求和响应之间的通信状态进行**保存**，不做持久化处理。

无状态协议解决办法： 通过1.Cookie  2.通过Session会话保存。

# HTTP报文格式

请求行（请求方法、URI、HTTP版本协议）+ 请求首部字段 + 请求内容实体

状态行（HTTP版本、状态码（数字和原因短语））+响应首部字段 + 响应内容实体

# HTTP方法

## GET

获取资源，用来访问已被URI识别的资源。

## POST

用来传输数据，GET用来获取资源

GET与POST的比较

作用：GET用于获取资源，POST用于传输实体主体

参数：**参数的位置不同**。GET和POST都能使用额外的参数，但是GET的参数以查询字符串出现在URL中，而POST参数存储在实体主体中。不能因为POST参数存储在实体主体中就认为它的**安全性更高**X，因为照样可以通过抓包（Fiddler）工具查看。

> URL只支持ASCII码，因此GET的参数如果存在中文等字符需要先编码（例如空格%20）。POST参数支持标准字符集

安全：安全的HTTP方法不会改变服务器的状态，也就是说它只是可读的。GET方法时安全的，而POST却不是，因为POST的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功后，服务器可能把数据存储到数据库中，因此状态也就发生了改变。

> 安全的方法：GET、HEAD、OPTIONS
>
> 不安全的方法：POST、PUT、DELETE

幂等性：同样的请求被执行一次或多次的效果是一样的，服务器的状态也是一样的。所有在安全方法也都是幂等的（GET、HEAD、PUT、DELETE），而POST不是。

> 对于幂等性可以这样理解：
>
> 首先GET请求很好理解，对资源做查询多次，此实现的结果都是一样的。 
> PUT请求的幂等性可以这样理解，将A修改为B，它第一次请求值变为了B，再进行多次此操作，最终的结果还是B，与一次执行的结果是一样的，所以PUT是幂等操作。 
>
> 同理可以理解DELETE操作，第一次将资源删除后，后面多次进行此删除请求，最终结果是一样的，将资源删除掉了。
>
> POST不是幂等操作，因为一次请求添加一份新资源，二次请求则添加了两份新资源，多次请求会产生不同的结果，因此POST不是幂等操作。

缓存：如果要对响应进行缓存，需要满足一下条件：

- 请求报文的HTTP方法本身是可缓存的，包括GET和HEAD，但PUT和DELETE不可以缓存，POST在多数情况下是不可以缓存的。
- 响应保温袋状态码是可缓存的，200、203、204、206、300、301、404、405、410、414和501
- 响应报文的Cache-Control首部字段没有指定不缓存

XMLHTTPRequest：更新数据时刷新部分页面

- 在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。
- 而 GET 方法 Header 和 Data 会一起发送。

## PUT

由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。

```
PUT /new.html HTTP/1.1
Host: example.com
Content-type: text/html
Content-length: 16

<p>New File</p>
```

PUT和POST的区别？

**幂等性**；通常情况下，PUT的URI指向是具体单一资源，而POST可以指向资源集合。

## PATCH

对资源进行部分修改。PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改

```
PATCH /file.txt HTTP/1.1
Host: www.example.com
Content-Type: application/example
If-Match: "e0023aa4e"
Content-Length: 100
[description of changes]
```

## DELETE

删除文件。不带验证机制

## OPTIONS

查询指定的URL支持的方法

会返回 `Allow: GET, POST, HEAD, OPTIONS` 这样的内容。

## CONNECT

> 要求在与代理服务器通信时建立隧道

## TRACE

追踪路径。服务器会将通信路径返回给客户端。

发送请求时在Max-Forwards首部字段中填入数值，每经过一个服务器就会减一，当数值为0时就会停止传输。

通常不会用TRACE，并且它容易受到XST攻击。

# 访问网址时，到底经历了什么？

DNS解析IP地址（浏览器缓存 chrome://net-internals/#dns、系统缓存（/etc/hosts）、路由器缓存、DNS服务器）

> 向DNS请求的过程中使用UDP协议、IP、ARP，其中有迭代查询和递归查询

取到IP地址后，和服务器通过三次握手建立TCP连接

浏览器向Web服务器发送HTTP请求

服务器处理请求(MVC后台框架)，发送一个HTML响应

浏览器开始显示响应，渲染页面

四次挥手断开连接



详细步骤请[参考网页](https://blog.csdn.net/qq_33699981/article/details/71294084)

# HTTP状态码

100 Continue:目前都正常，客户端可以继续发送请求或者忽略这个响应。

2XX 成功

- 200 OK，表示从客户端发来的请求在服务器端被正确处理
- 204 No content，表示请求成功，但响应报文不含实体的主体部分
- 206 Partial Content，进行范围请求

3XX 重定向

- 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL
- 302 found，临时性重定向，表示资源临时被分配了新的 URL
- 303 see other，表示资源存在着另一个 URL，应使用 **GET 方法获取资源**
- 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况
- 307 temporary redirect，临时重定向，和302含义相同。但是307要求浏览器不会把重定向请求的POST方法改成GET。

4XX 客户端错误

- 400 bad request，请求报文存在语法错误
- 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息
- 403 forbidden，表示对请求资源的访问被服务器拒绝
- 404 not found，表示在服务器上没有找到请求的资源

5XX 服务器错误

- 500 internal sever error，表示服务器端在执行请求时发生了错误
- 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求

# 首部字段

通用首部字段、请求首部字段、响应首部字段、以及实体首部字段

## 通用首部字段

|    首部字段名     | 说明                                       |
| :---------------: | :----------------------------------------- |
|   Cache-Control   | 控制缓存的行为                             |
|    Connection     | 控制不再转发给代理的首部字段、管理持久连接 |
|       Date        | 创建报文的日期时间                         |
|      Pragma       | 报文指令                                   |
|      Trailer      | 报文末端的首部一览                         |
| Transfer-Encoding | 指定报文主体的传输编码方式                 |
|      Upgrade      | 升级为其他协议                             |
|        Via        | 代理服务器的相关信息                       |
|      Warning      | 错误通知                                   |

## 请求首部字段

| 首部字段名          | 说明                                            |
| ------------------- | ----------------------------------------------- |
| Accept              | 用户代理可处理的媒体类型                        |
| Accept-Charset      | 优先的字符集                                    |
| Accept-Encoding     | 优先的内容编码                                  |
| Accept-Language     | 优先的语言（自然语言）                          |
| Authorization       | Web 认证信息                                    |
| Expect              | 期待服务器的特定行为                            |
| From                | 用户的电子邮箱地址                              |
| Host                | 请求资源所在服务器                              |
| If-Match            | 比较实体标记（ETag）                            |
| If-Modified-Since   | 比较资源的更新时间                              |
| If-None-Match       | 比较实体标记（与 If-Match 相反）                |
| If-Range            | 资源未更新时发送实体 Byte 的范围请求            |
| If-Unmodified-Since | 比较资源的更新时间（与 If-Modified-Since 相反） |
| Max-Forwards        | 最大传输逐跳数                                  |
| Proxy-Authorization | 代理服务器要求客户端的认证信息                  |
| Range               | 实体的字节范围请求                              |
| Referer             | 对请求中 URI 的原始获取方                       |
| TE                  | 传输编码的优先级                                |
| User-Agent          | HTTP 客户端程序的信息                           |

## 响应首部字段

| 首部字段名         | 说明                         |
| ------------------ | ---------------------------- |
| Accept-Ranges      | 是否接受字节范围请求         |
| Age                | 推算资源创建经过时间         |
| ETag               | 资源的匹配信息               |
| Location           | 令客户端重定向至指定 URI     |
| Proxy-Authenticate | 代理服务器对客户端的认证信息 |
| Retry-After        | 对再次发起请求的时机要求     |
| Server             | HTTP 服务器的安装信息        |
| Vary               | 代理服务器缓存的管理信息     |
| WWW-Authenticate   | 服务器对客户端的认证信息     |

## 实体首部字段

| 首部字段名       | 说明                   |
| ---------------- | ---------------------- |
| Allow            | 资源可支持的 HTTP 方法 |
| Content-Encoding | 实体主体适用的编码方式 |
| Content-Language | 实体主体的自然语言     |
| Content-Length   | 实体主体的大小         |
| Content-Location | 替代对应资源的 URI     |
| Content-MD5      | 实体主体的报文摘要     |
| Content-Range    | 实体主体的位置范围     |
| Content-Type     | 实体主体的媒体类型     |
| Expires          | 实体主体过期的日期时间 |
| Last-Modified    | 资源的最后修改日期时间 |

# Cookie

Cookie是服务器发送到用户浏览器并保存在本地的一块小数据。会在之后向同一服务器再次发起请求时被携带，用于告知服务器两次请求是否来自同一浏览器。

但现在随着现代浏览器开始支持各种各样的存储方式，**Cookie 渐渐被淘汰**。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。

**用途**

- 会话状态管理（用户登录状态、购物车、游戏分数）
- 个性化设置（用户自定义设置、主题等）
- 浏览器行为跟踪（跟踪分析用户行为等）

**创建过程**

服务器发送的响应报文中包含Set-Cookie首部字段，客户端得到响应报文后把Cookie内容保存到浏览器中。

```html
HTTP/1.0 200 OK
Content-type: text/html
Set-Cookie: yummy_cookie=choco
Set-Cookie: tasty_cookie=strawberry

[page content]
```

客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。

```
GET /sample_page.html HTTP/1.1
Host: www.example.org
Cookie: yummy_cookie=choco; tasty_cookie=strawberry
```

**分类**

- 会话期Cookie：浏览器关闭之后会自动删除，仅在会话期有效
- 持久性Cookie：过期时间或有效时间之后就成为了持久性的Cookie

**作用域**

Domain标识指定哪些主机可以接受Cookie

Path标识指定主机下的哪些路径可以接受Cookie

**HttpOnly**

不能被JavaScript脚本调用。XSS（跨站脚本攻击）常常使用JavaScript的document.cookieAPI窃取用户的Cookie信息，因此使用HttpOnly标记可以在一定程度上避免XSS攻击。

**Secure**

标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。

**Session**

利用Session存储在服务器端，存储在服务器端的信息更加安全

可以存储在服务器上的文件、数据库或者内存中。也可以将Session存储在Redis这种内存型的数据库中，效率会更高。

使用Session维护用户登录状态的过程如下：

- 用户登录，用户提交包含用户名密码的表单，放入HTTP请求报文中
- 服务器核验用户名密码，如果正确将用户信息存储到Redis中，它在Redis中的Key称为Session ID
- 服务器返回响应报文的Set-Cookie首部字段包含了这个Session ID，客户端收到响应后将该Cookie值存入浏览器中。
- 客户端之后对同一个服务器进行请求时会包含该Cookie值，服务器收到后取出Session ID，从Redis中取出用户信息，继续后续的业务操作。

安全性问题：不能让恶意攻击者轻易获取，需要产生一个不容易被猜到的Session ID值。此外，需要经常更新Session ID。在安全性要求极高的场景下，例如转账等操作，除了使用Session管理用户状态外，还需要对用户进行重新验证。

禁用Cookie以后，只能使用Session。并将Session ID放入到URL的参数进行传递

**Cookie与Cookie的选择**

- Cookie只能存储ASCII码字符串，而Session则可以存储任何类型的数据，因此考虑**数据复杂性**时首选Session。
- Cookie存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在Cookie中，可以将Cookie加密，然后在服务器端解密。
- 对于大型网站，如果用户所有的信息都存储在Session中，那么开销是非常大的，因此不建议将所有的用户信息都存储Session中。

# 缓存

1. 优点

   缓解服务器压力；降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。

2. 实现方法

   - 代理服务器实现缓存
   - 客户端浏览器进行缓存

3. Cache-Control

   HTTP/1.1通过Cache-Control首部字段来控制缓存	

   禁止进行缓存 no-store

   强制确认缓存 no-cache 只有当缓存资源有效时，才能使用该缓存

   私有缓存和公共缓存private、public：私人使用或者多个用户共同使用

   缓存过期机制max-age：在请求报文表示缓存资源的缓存时间小于该指令指定的时间，那么就接受该缓存。出现在响应报文中，表示缓存资源在缓存服务器中保存的时间。Expires首部字段可以用于告知缓存服务器该资源什么时候过期。

4. 缓存验证

   ETag首部字段表示资源的唯一标识。URL不能唯一标识，因为有多种语言的URL。

   ```
   ETag: "82e22293907ce725faf67773957acd12"
   ```

   可以将缓存资源的 ETag 值放入 If-None-Match 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modified。

   > If-None-Match: "82e22293907ce725faf67773957acd12"

   ETag的备用方案：Last-Modified首部字段可以用于缓存验证，包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。只能精确到1秒。如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有实体主体的 304 Not Modified 响应报文。



# 内容编码

为了减少传输的数据量

gzip、compress、deflate、identity

# HTTPS

HTTP有以下安全性问题：

- 使用明文进行通信，内容可能被窃听
- 不验证通信方的身份，身份可能遭遇伪装
- 无法证明报文的完整性，报文有可能被篡改

HTTPS=加密（防止被窃听）+认证（防伪装）+完整性保护（防篡改）

## 加密

### 1. 对称密钥加密

加密和解密使用同一密钥

- 优点：运算速度快
- 缺点：无法安全地将密钥传输给通信方

### 2. 非对称密钥加密

加密和解密使用不同的密钥

公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。

非对称密钥除了用来加密，还可以用来进行**签名**。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。

- 优点：可以更安全地将公开密钥传输给通信发送方
- 缺点：运算速度慢

### 3.HTTPS采用的加密方式

HTTPS采用混合的加密机制，使用非对称密钥加密用于传输对称秘钥来保证传输过程的安全性，之后使用对称秘钥加密进行通信来保证通信过程的效率

## 认证

通过使用 **证书** 来对通信方进行认证。

Certificate Authority（CA）是客户端与服务器双方都可以信赖的第三方机构。

服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。

进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。

## 完整性保护

SSL提供报文摘要功能来进行完整性保护

HTTP 也提供了 MD5 报文摘要功能，但不是安全的。

HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。

## HTTPS的缺点

- 因为需要进行加密解密等过程，因此**速度会更慢**；
- 需要支付证书授权的高额费用。

# HTTP/2.0

HTTP/1.x 实现简单是以牺牲性能为代价的：

- 客户端需要使用多个连接才能实现并发和缩短延迟；
- 不会压缩请求和响应首部，从而导致不必要的网络流量；
- 不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。

## 二进制分帧层

将报文分成HEADERS帧和DATA帧，都是二进制格式的。

在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。

- 一个数据流（Stream）都有一个唯一标识符和可选的优先级信息，用于承载双向信息。
- 消息（Message）是与逻辑请求或响应对应的完整的一系列帧。
- 帧（Frame）是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。

## 服务器推送

HTTP/2.0 在客户端请求一个资源时，**会把相关的资源一起发送给客户端**，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。

 ## 首部压缩

HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。

HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。

不仅如此，HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩。

## HTTP/1.1新特性

- 默认是长连接，1.0默认是多连接，如果使用长连接，使用Connection：Keep-Alive
- 支持流水线：不要等待响应，就可以连续发出多个请求
- 支持同时打开多个TCP连接
- 支持虚拟主机：一台服务器拥有多个域名，并且在逻辑上可以看成多个服务器
- 新增状态码100
- 支持分块传输编码：把数据分割成多块，让浏览器逐步显示页面
- 新增缓存处理指令max-age