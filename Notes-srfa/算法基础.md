# 一、数组

## 数组的基本概念

数组（Array）：一种线性表的数据结构。用一组连续的内存空间来存储一组具有相同数据类型的数据

- 线性表与非线性表
  - 线性表（Linear List）：数据排成像一条线一样的结构。每个线性表上的数据最多只有前后两个方向的数据。例如：数组、链表、队列、栈
  - 非线性表：数据之间不是简单的前后关系，例如：二叉树、堆、图
- 连续的内存空间和相同类型的数据
  - 这个两个限制使得数组有一个杀手级的特性：随机访问。即根据下标随机访问的时间复杂度为O（1）。但是要注意数组中查找一个元素的时间复杂度不是O(1)。
  - 因为需要连续的内存空间，因此对于插入和删除操作非常低效。

## 数据基本操作

- 插入

  - 实现：将某个元素插入到数据第k个位置，需要将k~n部分的元素向后搬移一位，然后插入元素。若插入到数组的末尾，时间复杂度为O(1)；插入到数组的开头，时间复杂度为O(n)；插入的平均时间复杂度为（1+2+3+...+n）/n=O(n)。注意这个实现针对的数组是有序的。
  - **优化**：若数组只是一个存储数据的集合，其元素是无序的，则插入时不需要搬移数据。插入到数据第k个位置的思路为：将该位置的元素移动到数组末尾，然后将待插入元素插入到第k个位置，时间复杂度为O(1)。注意：这个优化是针对数据是无序的，这个优化其实是放弃了数组逻辑上的连续

- 删除

  - 实现：删除第k个位置，则需要将k+1~n个元素向前搬移一位。若要删除末尾，时间复杂度为O(1)；

    删除开头，时间复杂度O(n)；删除平均复杂度为O(n)

  - 优化：将多次删除一起执行。当我们需要删除多个元素时，并不立即执行搬移操作，而是将多个元素标记为已删除，然后当数组满了的时候，将标记的元素一起删除，这样就减少了搬移次数，提高了效率。这就是**JVM中的标记-删除算法核心思想**

- 随机访问

  - 实现：数组的随机访问，只需要根据首地址和下标通过寻址公式计算出对应内存地址即可

## 数据的内存模型

- 访问数组的本质：计算机为每一个数组分配了一段连续的内存，计算机通过访问内存的地址访问内存，因此访问数组的本质就是访问一段连续内存。对内存的要求较高
- 既然访问数组其实是访问一段内存，那么计算机就可以根据数组的首地址和下标，通过计算公式计算出每个元素所在的位置，数组访问寻址公式：
  - 给定一维数组a[n],则a[k]的内存地址为：`a[k]_address = base_address + k * type_size`
  - 给定二维数组`a[m][n]`则`a[i][j]`的内存地址为：`a[i][j]_address = base_address + (i*n + j) * type_size `。

# 二、链表

链表（Linked List）：一种线性表数据结构。它用一组不连续的内存空间来存储一组具有相同数据类型的数据。

## 链表的基本操作

- 插入：链表的插入操作只需要调整前后节点的指针即可，时间复杂度为O(1)
- 删除：链表的删除只需要调整前后节点的指针即可，O(1)
- 随机访问：链表的随机访问，无法像数组一样通过寻址公式计算出下标的内存位置，只能通过遍历找到相应的节点，O(n)

## 链表的分类

### 1. 单链表

结构：head -> data -> data -> null

特点：结构简单，但是随机访问某个节点时，只能从头到尾，找到这个节点

### 2. 循环链表

结构：head -> data -> data -> head

特点：与单链表相比，其优势在于可以从尾到头遍历。

### 3. 双向链表

结构：head <-> data <-> data -> null

特点：最大的优势在于找到前驱节点的时间复杂度为O(1)，正因为这个特点，使得双向链表在某些情况下，插入、删除等操作比单链表简单高效，尽管时间复杂度都是O(1)。虽然占用的内存要高于单链表，但是日常使用，双向链表更加常用。**Java中LinkedHashMap就用双向链表来记录插入的插入的键值对的顺序**

### 4. 双向循环链表

双向循环链表是双向链表与循环链表的组合

### 问题：为什么双向链表比单链表高效?

#### 插入和删除

（1）删除操作

在实际开发中，从链表删除一个数据主要有以下两种情况：

- 删除某个值等于给定值的节点
- 删除给定指针指向的节点

事实上，删除操作本身的时间复杂度为O(1),单链表和双向链表的性能差别，主要在于查找的过程。

对于第一种情况，无论单链表还是双向链表，无论是插入还是删除，都需要从头到尾遍历找到“值等于给定值”的节点，因此二者的时间复杂度均为O(n)。

对于第二种情况，已经找到了要删除的节点（记为q），但是要删除这个节点需要知道其前驱节点(记为p)。单链表中，无法立即知道q的前驱节点p,因此只能从头遍历，直到`p->next = q`，这个过程的时间复杂度是O(n); 而双向链表要删除的节点q已经保存了前驱节点p的指针。因此可以O(1)的时间找到p。因此单链表删除操作时间复杂度为O(n)，而双向链表为O(1)。

（2）插入操作

分析同上

#### 查找

对于有序链表，双向链表按值查找的效率要高于单链表。因为我们可以记录上一次查找的位置p，每次查找时，比较要查找的值与p的关系，若小于p，则向前查找，反之则向后，平均只需要查找一半的数据

因此双向链表在删除和插入给定节点以及在有序链表中查找值这几种情况下，效率要高于单链表。

事实上，这里的双向链表的性能来自于其对空间的牺牲，它的空间占用要高于单链表，体现了 **“空间换时间”** 的设计思想。

### 数组 VS 链表

### 1. 内存

从内存来讲，数组要求内存是一块连续的内存空间，而链表则不需要内存空间连续。例如，如果申请一个100MB大小的数组，当内存中没有连续的大于等于100MB的内存空间时，即使内存的总空间大于100MB，内存也会申请失败；而链表则不需要连续的内存空间，链表通过指针将不同的内存块串联起来，如果内存的总空间大100MB，那么申请100MB的链表则没有任何问题。

尽管数组需要连续的内存空间，对内存的要求较高，但是正因为这个特性，数组可以借助**CPU缓存机制**，预读数组中的数据，因此访问效率更高。而链表由于内存不连续，因此对CPU缓存不友好，无法预读。

若代码对内存使用比较苛刻，那么使用数组会比较好。因为链表的每个节点都需要使用额外的内存存储指向下一个节点的指针，额外内存高于数组。

链表在进行插入和删除操作的时候，导致内存频繁的申请和释放，容易造成内存碎片。在Java中，有可能到导致频繁的GC。

### 2. 基本操作

| 时间复杂度 | 数组 | 链表 |
| :--------: | :--: | :--: |
| 插入、删除 | O(n) | O(n) |
|  随机访问  | O(1) | O(n) |

根据二者的时间复杂度，在随机访问更加频繁的场景下（插入、删除操作非常少），数组更加适用；在插入、删除操作频繁的场景下，链表更加适用。

# 三、树

# 四、栈和队列

