# 数组和矩阵

## 1.二维数组查找

在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

## 2.旋转数组中的最小数字

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。

二分法思路

## 3.调整数组顺序使奇数位于偶数前面

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。

> 思路1.新建一个数组，空间复杂度O(N)，时间复杂度O(N)
>
> 思路2：冒泡或者插入排序的思路都可以使用；冒泡(前偶后奇就交换)，插入排序（前半部分为奇数数组，后面每遇到一个奇数，就和前面的偶数直到遇到奇数为止）

## 4.数组中出现次数超过一半的数字

数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。

> 思路：如果有符合条件的数字，则它出现的次数比其他所有数字出现的次数和还要多。在遍历数组时保存两个值：一是数组中一个数字，一是次数。遍历下一个数字时，若它与之前保存的数字相同，则次数加1，否则次数减1；若次数为0，则保存下一个数字，并将次数置为1。遍历结束后，所保存的数字即为所求。然后再判断它是否符合条件即可。

## 5.连续子数组的最大和

HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)

> 思路1：计算每次的累加和，如果大于等于零继续累加，如果小于零重新开始计算。
>
> 思路2：F（i）：以array[i]为末尾元素的子数组的和的最大值，子数组的元素的相对位置不变
>
> ​		      F（i）=max（F（i-1）+array[i] ， array[i]）
>
> ​              res：所有子数组的和的最大值
>
> ​              res=max（res，F（i））

## 6.把数组排成最小的数

输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。

> 贪心思路：先将整型数组转换成String数组，然后将String数组排序，最后将排好序的字符串数组拼接出来。关键就是制定排序规则。

## 7.数组中的逆序对

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007

> merge思路应用

## 8.数组中只出现一次的数字

一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。

> 思路:疯狂地异或,你学会了吗?

## 9.数字在排序数组中出现的次数

统计一个数字在排序数组中出现的次数。

> 又是一道冒泡思路,技巧:可以查找k+0.5 和 k-0.5的位置,二者做差就是次数

## 10.数组中重复的数字

在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。

> 首先想到使用hash算法，保证O(N)的时间复杂度，但是会带来额外的O(N)空间复杂度。可以在原来的数组做一个hash，因为题目的所有数字都在0到n-1的范围内。

~~~java
 public boolean duplicate(int numbers[],int length,int [] duplication) {
        if(numbers==null || length<=0)
            return false;
        for(int i=0;i<length;i++){
            while(numbers[i]!=i){
                if(numbers[i]==numbers[numbers[i]]){
                    duplication[0]=numbers[i];
                    return true;
                }
                int temp=numbers[i];
                numbers[i]=numbers[temp];
                numbers[temp]=temp;
            }
        }
        return false;
    }
~~~

## 11.构建乘积数组

给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]。不能使用除法。

> 将B[i]分成两部分，先乘积完成前面部分，然后再乘后面的乘积部分

~~~java
import java.util.ArrayList;
public class Solution {
    public int[] multiply(int[] A) {
        int length=A.length;
        int[]B=new int[length];
        B[0]=1;
        for(int i=1;i<length;i++){
            B[i]=A[i-1]*B[i-1];
        }
        int tmp=1;
        for(int i=length-2;i>=0;i--){
            tmp=tmp*A[i+1];
            B[i]=tmp*B[i];
        }
        return B;
    }
}
~~~

# 字符串

## 1.字符串的排列

输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。

> 思路1：按照字典序的思路可以完成，问题关键在于如何计算一个字符串的字典序。
>
> 思路2：递归思路，完成每次的替换。

~~~java
 public static void main(String[] args) {
        String str="abcb";
        char[]c=str.toCharArray();
        //Arrays.sort(c);
        while(nextPermutation(c))
            System.out.println(String.valueOf(c));
    }

    private static boolean nextPermutation(char[]chars){
        int len=chars.length;

        int i=len-2;
        //从倒数第二个字符开始,从右向左,找到第一个破坏从右向左递增顺序的数字
        while(i>=0 && chars[i]>=chars[i+1])i--;
        if(i<0)return false;
        int k=len-1;
        //从右向左,找到第一个大于char[i]的数字
        while(k>i&& chars[k]<=chars[i])k--;
        //交换两个数字后，逆序后面的序列
        swap(chars,i,k);
        reverse(chars,i+1,len-1);
        return true;
    }

    private static void swap(char[]c,int i,int j){
        char cc=c[i];
        c[i]=c[j];
        c[j]=cc;
    }

    private static void reverse(char[]c,int a,int b){
        while(a<=b){
            swap(c, a++, b--);
        }
    }
~~~

~~~java
import java.util.ArrayList;
import java.util.Collections;
public class Solution {
    private ArrayList<String>list=new ArrayList<>();
    public ArrayList<String> Permutation(String str) {
       //ArrayList<String>list=new ArrayList<>();
       process(str.toCharArray(),0);
       Collections.sort(list);
        return list;
    }
     
    private void process(char[]c,int begin){
        if(begin==c.length-1){
            list.add(String.valueOf(c));
        }else{
            for(int i=begin;i<c.length;i++){
                if(isSwap(c,begin,i)){
                    swap(c,i,begin);
                    process(c,begin+1);
                    swap(c,i,begin);
                }
            }
        }
    }
    private boolean isSwap(char[]c,int begin,int end){
        for(int i=begin;i<end;i++){
            if(c[i]==c[end])
                return false;
        }
        return true;
    }
     
      private static void swap(char[]c,int i,int j){
        char tmp=c[i];
        c[i]=c[j];
        c[j]=tmp;
    }
}
~~~

# 栈和队列

## 1.用数组实现一个栈和队列

## 

# 链表

## 1.反转链表

## 2.删除倒数第k个结点

## 3.删除中间结点

## 4.判断链表是否具有回文结构

# 树

## 1.遍历一颗树

递归和非递归版本

# 动态规划





