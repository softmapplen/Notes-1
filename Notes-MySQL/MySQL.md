# Table of Contents

* [数据库MySQL知识点框架](#数据库mysql知识点框架)
* [一、数据库索引](#一数据库索引)
  * [索引的应用场景](#索引的应用场景)
  * [索引特点](#索引特点)
  * [索引优点和缺点](#索引优点和缺点)
  * [索引的分类](#索引的分类)
    * [1.B+Tree索引](#1btree索引)
    * [2.哈希索引](#2哈希索引)
      * [哈希索引的限制](#哈希索引的限制)
    * [3.空间数据索引](#3空间数据索引)
    * [4.全文索引](#4全文索引)
  * [索引选择原则](#索引选择原则)
  * [索引的优化](#索引的优化)
  * [索引失效](#索引失效)
  * [索引的底层实现（B-Tree vs B+Tree）](#索引的底层实现b-tree-vs-btree)
  * [对于建立索引的列，数据均匀分布好还是不均匀好？](#对于建立索引的列数据均匀分布好还是不均匀好)
* [二、数据库存储引擎比较](#二数据库存储引擎比较)
  * [InnoDB](#innodb)
  * [MyISAM](#myisam)
  * [Memory](#memory)
  * [比较](#比较)



# 数据库MySQL知识点框架

- 数据库范式
- 数据库事务
  - 什么是事务？
  - 事务特性：ACID
  - 事务隔离级别以及脏读、不可重复读、幻读
  - 分布式事务
- 数据库索引
  - 索引的应用场景
  - 索引特点
  - 索引的优点和缺点
  - 索引的分类
  - 索引选择原则
  - 索引的优化
  - 索引失效
  - 索引的底层实现（B-Tree vs B+Tree）
  - 对于建立索引的列，数据均匀分布好还是不均匀好？
- 数据库的锁
  - 行锁 vs 表锁
  - 读锁 vs 写锁
  - 乐观锁 vs 悲观锁以及如何实现？（MVCC）
  - 加锁的方式
  - 分布式锁
- 数据库存储引擎比较
  - InnoDB
  - MyISAM
  - Memory
- MySQL连接池对比
- MySQL命令
- JOIN的执行计划
- 数据库分库分表
- 主从复制

# 一、数据库索引

> 本章内容可以结合算法中的查找进行学习整理

## 索引的应用场景

1. 快速查找符合where条件的记录
2. 对于使用MIN或MAX函数的查询
3. 对于ORDER BY 和GROUP BY，MySQL经常使用索引来高效完成分类和分组
4. 如果表中存在几个字段的联合索引，则查找记录时，这个索引的最左前缀匹配字段也会被自动作为索引来加速查找
5. 多表做JOIN操作时

## 索引特点

## 索引优点和缺点

优点
- 大大减少了服务器需要扫描的数据量

- 可以帮助服务器避免排序和临时表

- 可以将随机IO变为顺序IO

缺点

- 降低了大部分与写入相关的操作的速度

- 占用磁盘空间，多个索引会占用的更大的空间

## 索引的分类

索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。

### 1.B+Tree索引

大多数MySQL存储引擎的默认索引类型

不需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多

B+Tree的有序性，顺序组织存储，适合查找范围数据、排序和分组

可以指定多个列作为索引，多个索引列共同组成键

适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。可以只访问索引的查询

InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。

辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。

### 2.哈希索引

memory引擎显示支持哈希索引，且为默认索引。也可以创建自定义哈希索引（伪索引列，使用触发器来维护哈希索引）

非唯一的哈希索引（对于相同哈希值，会以链表的方式存放多个记录指针到同一个哈希表目中）

InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。

#### 哈希索引的限制

- 只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。
- 无法排序
- 不支持部分索引匹配查找
- 只支持等值比较查询，不支持任何范围查询
- 哈希冲突越多，代价也就越大。（遍历链表所有的行指针，进行比较，直到找到所有符合条件的行）

### 3.空间数据索引

MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。

必须使用 GIS 相关的函数来维护数据。

### 4.全文索引

MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。

查找条件使用 MATCH AGAINST，而不是普通的 WHERE。

全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。

InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。

## 索引选择原则

## 索引的优化

## 索引失效

## 索引的底层实现（B-Tree vs B+Tree）

## 对于建立索引的列，数据均匀分布好还是不均匀好？

# 二、数据库存储引擎比较

## InnoDB

MySQL默认的事务型引擎，只有在需要它不支持的特性时，才考虑使用其他引擎

实现四个标准的隔离级别，默认级别为可重复读。在可重复读隔离级别下，通过多版本控制+间隙锁（Next-Key Locking）来消除幻影读。

主索引是聚族索引，在索引中保存了数据，从而避免直接读磁盘，因此对查询性能有很大提升

内部做了很多优化，包括从磁盘读取数据时采用的可预测性预读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区

支持真正的在线热备份。其他引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。

## MyISAM

设计简单，数据以紧凑格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。

提供了大量的特性，包括压缩表、空间数据索引

不支持事务

不支持行级锁，只能对整张表加锁，读取时会对需要读到数据的所有表加共享锁，写入时则对表加排他锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称作并发插入（CONCURRENT INSERT）

可以手动或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能会导致一些数据丢失，而且修复操作非常慢。

延迟更新索引键（Delayed Key Write）如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。

## Memory

1. 数据保存在内存中，重启以后会丢失（结构保留但数据会丢失），不需要进行磁盘IO操作。

2. 支持哈希索引。

3. 是表级锁，并发写入的性能较低。

4. 应用场景
   - 用于查找或者映射表
   - 缓存周期性聚合数据的结果
   - 用于保存数据分析中产生的中间数据

## 比较

|   区别   |     InnoDB     |                      MyISAM                      |
| :------: | :------------: | :----------------------------------------------: |
|   事务   |      支持      |                      不支持                      |
|   并发   |     行级锁     |                      表级锁                      |
|   外键   |    支持外键    |                      不支持                      |
|   备份   | 支持在线热备份 |                      不支持                      |
| 崩溃恢复 |                | 崩溃后发生损坏的概率比InnoDB高很多，恢复速度更慢 |
| 其他特性 |                |             支持压缩表和空间数据索引             |

## Redis 和 Memcache

数据类型：Redis支持String、List、Set、Sorted Set、Hash，而memcache支持简单数据类型

持久性：Redis支持持久化操作，而memcache不支持

分布式存储：redis支持master-slave复制模式，memcache可以使用一致性hash做分布式

value大小不同：memcache是一个内存缓存，key的长度小于250字符

数据一致性不同：Redis支持单线程操作，保证数据按顺序提交。而memcache需要使用CAS保证数据的一致性。

# 三、一致性哈希

[分布式缓存中的一致性哈希算法，这篇文章给讲透了！](https://juejin.im/post/5d0781c1f265da1b827a9ca2)

## Memcached 与客户端分布式缓存

Memcached 是一个高性能的分布式缓存系统，然而服务端没有分布式功能，各个服务器不会相互通信。

它的分布式实现依赖于客户端的程序库，这也是 Memcached 的一大特点。比如第三方的 spymemcached 客户端就基于一致性哈希算法实现了其分布式缓存的功能。

其具体步骤如下:

- 向 Memcached 添加数据，首先客户端的算法根据 key 值计算出该 key 对应的服务器。
- 服务器选定后，保存缓存数据。
- 获取数据时，对于相同的 key ，客户端的算法可以定位到相同的服务器，从而获取数据。

在这个过程中，客户端的算法首先要保证缓存的数据尽量均匀地分布在各个服务器上，其次是当个别服务器下线或者上线时，会出现数据迁移，应该尽量减少需要迁移的数据量。

其中，客户端算法是客户端分布式缓存性能优劣的关键。

普通的哈希表算法一般都是计算出哈希值后，通过取余操作将 key 值映射到不同的服务器上

但是当服务器数量发生变化时，取余操作的除数发生变化，所有 key 所映射的服务器几乎都会改变，这对分布式缓存系统来说是不可以接收的。

**一致性哈希算法能尽可能减少了服务器数量变化所导致的缓存迁移。**

## 哈希算法

**MD5 算法**：全称为 Message-Digest Algorithm 5，用于确保信息传输完整一致。是计算机广泛使用的杂凑算法之一，主流编程语言普遍已有 MD5 实现。

MD5 的作用是把大容量信息压缩成一种保密的格式（就是把一个任意长度的字节串变换成定长的16进制数字串）。常见的文件完整性校验就是使用 MD5。

**CRC 算法**：全称为 CyclicRedundancyCheck，中文名称为循环冗余校验。它是一类重要的，编码和解码方法简单，检错和纠错能力强的哈希算法，在通信领域广泛地用于实现差错控制。

**MurmurHash 算法**：高运算性能，低碰撞率，由 Austin Appleby 创建于 2008 年，现已应用到 Hadoop、libstdc++、nginx、libmemcached 等开源系统。

Java 界中 Redis，Memcached，Cassandra，HBase，Lucene和Guava 都在使用它。

**FNV 算法**：全称为 Fowler-Noll-Vo 算法，是以三位发明人 Glenn Fowler，Landon Curt Noll，Phong Vo 的名字来命名的，最早在 1991 年提出。 

FNV 能快速 hash 大量数据并保持较小的冲突率，它的高度分散使它适用于 hash 一些非常相近的字符串，比如 URL，hostname，文件名，text 和 IP 地址等。

**Ketama 算法**：一致性哈希算法的实现之一，其他的哈希算法有通用的一致性哈希算法实现，只不过是替换了哈希映射函数而已，但 Ketama 是一整套的流程，我们将在后面介绍。

## 一致性哈希算法

首先将缓存服务器（ ip + 端口号）进行哈希，映射成环上的一个节点，计算出缓存数据 key 值的 hash key，同样映射到环上，并顺时针选取最近的一个服务器节点作为该缓存应该存储的服务器。具体实现见后续的章节。

![](image/Snipaste_2019-08-05_15-21-21.png)

当服务器 B 宕机下线，服务器 B 中存储的缓存数据要进行迁移，但由于一致性哈希环的存在，只需要迁移key 值为1的数据，其他的数据的存储服务器不会发生变化。这也是一致性哈希算法比取余映射算法出色的地方。

现实情况下，服务器在一致性哈希环上的**位置不可能分布的这么均匀**，导致了每个节点实际占据环上的区间大小不一。这种情况下，可以**增加虚节点**来解决。通过增加虚节点，使得每个节点在环上所“管辖”的区域更加均匀。这样就既保证了在节点变化时，尽可能小的影响数据分布的变化，而同时又保证了数据分布的均匀。